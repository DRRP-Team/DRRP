/**
 * Copyright (c) 2017-2022 DRRP-Team
 * 
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

version "2.5"

#include "zscript/Patches.zsc"
#include "zscript/Actors.zsc"
#include "zscript/Weapons.zsc"

#include "zscript/MonsterProjectiles.zsc"
#include "zscript/MonstersBaseDRRP.zsc"
#include "zscript/Monsters.zsc"

// APIs
#include "zscript/DRRP_API/APIWeapons.zsc"
#include "zscript/DRRP_API/APIConversation.zsc"
#include "zscript/DRRP_API/APIInput.zsc"
#include "zscript/DRRP_API/APIShaders.zsc"
#include "zscript/DRRP_API/APINotebook.zsc"

// Visual
#include "zscript/DRRP_MiscClasses/Infobar.zsc"
#include "zscript/DRRP_MiscClasses/Compass.zsc"
#include "zscript/DRRP_MiscClasses/StatInfo.zsc"
#include "zscript/DRRP_MiscClasses/Flashlight.zsc"
//#include "zscript/DRRP_MiscClasses/HUD.zsc" // Errr, "NullHUD"?

// Tools
#include "zscript/RPGSystem.zsc"
#include "zscript/DRRP_MiscClasses/Utils.zsc"



class DRRPPlayer: DoomPlayer {
    static const String dogNames[] = { "HellHound", "Cerberus", "DemonWolf" };
    const TICKS_BETWEEN_LOW_HEALTH_SOUND = 70; // [PROPHESSOR]: why can't I make it static const? // [McM]: why not?

    int playerStats[ _RPG_Quantity ]; //Experience, NextLevelXP, Level, Accuracy, Agility, Defense, Strength, MaxArmor;

    bool lowHealthIndicatorEnabled;
    int lowHealthIndicatorTimer;

    Array<String> MapsMonstersDone;
    Array<String> MapsSecretsDone;

    vector3 PreFreezeVel;

    override void BeginPlay() {
        playerStats[ RPG_Experience ] = playerStats[ RPG_Accuracy ] = 0;
        playerStats[ RPG_Agility ] = playerStats[ RPG_Defence ] = playerStats[ RPG_Strength ] = 0;
        playerStats[ RPG_Level ] = 1;
        playerStats[ RPG_MaxArmor ] = playerStats[ RPG_MaxHealth ] = 30;

        SetAllPlayerLevelupFeatures();

        lowHealthIndicatorTimer = -1;
        lowHealthIndicatorEnabled = false;

        Shader.SetEnabled(player, "HeatHaze", true);

        Super.BeginPlay();
    }

    void healthIndicatorTick() {
        if ( !( level.maptime % 35 ) ) // Update the variable every second automatically.
            lowHealthIndicatorEnabled = CVar.GetCVar( "drrp_enable_low_health_indicator", player ).GetBool();

        if ( lowHealthIndicatorEnabled && health > 0 ) {
            // Play sound on low health.
            bool islowHealthIndicator = health / double( playerStats[ RPG_MaxHealth ] ) < 0.35;
            if ( islowHealthIndicator ) {
                lowHealthIndicatorTimer += 1;
                lowHealthIndicatorTimer %= TICKS_BETWEEN_LOW_HEALTH_SOUND;

                if ( !lowHealthIndicatorTimer ) {
                    S_Sound( "player/lowhp", CHAN_BODY | CHAN_MAYBE_LOCAL );
                    A_SetBlend( "AA0000", 0.2, 5 );
                }
            } else if ( lowHealthIndicatorTimer != -1 ) {
                lowHealthIndicatorTimer = -1;
            }
        }
    }

    const TEMPERATURE_MIN_DISTANCE = 128;

    float getTemperature() {
        float maxTemperature = 0.0;

        ThinkerIterator lavaIterator = ThinkerIterator.Create("DRRPLava");

        for (DRRPLava lava; lava = DRRPLava(lavaIterator.Next());) {
            double distance = Distance2D(lava);

            if (distance > TEMPERATURE_MIN_DISTANCE) continue;

            float temperature = 1.0 - (distance / TEMPERATURE_MIN_DISTANCE);

            if (maxTemperature < temperature) maxTemperature = temperature;
        }

        ThinkerIterator fireIterator = ThinkerIterator.Create("DRRPFire");

        for (DRRPFire fire; fire = DRRPFire(fireIterator.Next());) {
            double distance = Distance2D(fire);

            if (distance > TEMPERATURE_MIN_DISTANCE) continue;

            float temperature = (1.0 - (distance / TEMPERATURE_MIN_DISTANCE)) / 2;

            if (maxTemperature < temperature) maxTemperature = temperature;
        }

        return maxTemperature;
    }

    void heatShaderTick() {
        float temperature = getTemperature();

        // Console.Printf("Temperature: "..temperature);

        Shader.SetEnabled(player, "HeatHaze", true);
        Shader.SetUniform1f(player, "HeatHaze", "Temperature", temperature);
        A_SetBlend("AA5500", temperature, 5);
    }

    override void PlayerThink() {
        Super.PlayerThink();

        healthIndicatorTick();

        if (CVar.FindCVar("drrp_enable_temperature_shader").GetBool())
            heatShaderTick();
        else
            Shader.SetEnabled(player, "HeatHaze", false);
    } // of override void PlayerThink() {


    /* Static get/set features methods (usually for ACS) */
    static int GetFeatureStatic( Actor activator, int type ) {
        int outValue = -1;

        if ( activator && activator.player && ( activator is "DRRPPlayer" ) )
            outValue = DRRPPlayer( activator ).GetFeature( type );

        return outValue;
    }

    static void SetFeatureStatic( Actor activator, int type, int value, bool setFeatureConsequence = true ) {
        if ( ( value < 0 ) || !activator || !activator.player || !( activator is "DRRPPlayer" ) )
            return;

        DRRPPlayer( activator ).SetFeature( type, value, setFeatureConsequence );
    }

    static void AddFeatureStatic( Actor activator, int type, int diffvalue, bool setFeatureConsequence = true ) {
        if ( !activator || !activator.player || !( activator is "DRRPPlayer" ) )
            return;

        DRRPPlayer( activator ).AddFeature( type, diffvalue, setFeatureConsequence );
    }

    /* Overridable feature types */
    virtual void SetLevelFeatures() {
        playerStats[ RPG_NextLevelXP ] += playerStats[ RPG_Level ] * 20;
    }

    virtual void SetAgilityFeatures() {
        self.ForwardMove1 = playerStats[ RPG_Agility ] * 0.025 + 0.6;
        self.ForwardMove2 = self.ForwardMove1 * 0.58333;
        self.SideMove1    = playerStats[ RPG_Agility ] * 0.025 + 0.55;
        self.SideMove2    = self.SideMove1 * 0.54545;
    }

    virtual void SetHealthFeatures() {
        self.maxHealth = self.health = playerStats[ RPG_MaxHealth ];
        self.GiveInventory( "DRRPHealthVial", 999 );
        self.MugShotMaxHealth = playerStats[ RPG_MaxHealth ];
    }

    virtual void SetArmorFeatures() {
        Inventory armor = FindInventory( "DRRPBasicArmor" );
        if ( armor ) 
            armor.MaxAmount = playerStats[ RPG_MaxArmor ];
    }

    virtual void SetDefenceFeatures() {}

    virtual void SetAccuracyFeatures() {}

    virtual void SetStrengthFeatures() {}


    /* Features getter/setter */
    clearscope int GetFeature( int type ) {
        return ( type >= _RPG_FirstStat && type <= _RPG_Quantity )? playerStats[ type ]: -1;
    }

    void SetFeature( int type, int value, bool setFeatureConsequence = true ) {
        CVar debugCVar = CVar.GetCVar( "drrp_debug_mode", players[ consoleplayer ] );
        if ( debugCVar && debugCVar.GetBool() )
            console.printf( GetClassName() .. "::SetFeature(). playerStats[ " .. type .. " ] = " .. value .. "; " .. ( setFeatureConsequence? "call" : "don't call" ) .. " consequence." );

        if ( type >= _RPG_FirstStat && type <= _RPG_Quantity ) {
            playerStats[ type ] = value;

            if ( setFeatureConsequence )
                switch ( type ) {
                    case RPG_MaxHealth:   setHealthFeatures();  break;
                    case RPG_MaxArmor:    setArmorFeatures();   break;
                    case RPG_Experience:  
                    case RPG_NextLevelXP: EventHandler.SendNetworkEvent( "DRRP_Exp_Check", consoleplayer ); break;

                    case RPG_Level:       setLevelFeatures();    break;
                    case RPG_Accuracy:    setAccuracyFeatures(); break;
                    case RPG_Agility:     setAgilityFeatures();  break;
                    case RPG_Defence:     setDefenceFeatures();  break;
                    case RPG_Strength:    setStrengthFeatures(); break;
                    default: break;
                }
        }
    } // of void SetFeature( int type, int value, bool setFeatureConsequence = true ) {

    void AddFeature( int type, int diffvalue, bool setFeatureConsequence = true ) {
        SetFeature( type, diffvalue + GetFeature( type ), setFeatureConsequence );
    }


    /* Sets all player level up features. */
    void SetAllPlayerLevelupFeatures( void ) {
        SetLevelFeatures();

        SetAccuracyFeatures();
        SetAgilityFeatures();
        SetDefenceFeatures();
        SetStrengthFeatures();

        SetHealthFeatures();
        SetArmorFeatures();
    } // of void setAllPlayerLevelupFeatures( DRRPPlayer player ) {

    virtual void AddAllPlayerLevelupStats( void ) {
        // Let's think that this is AddFeature() calls...
        playerStats[ RPG_Level ]     += 1;
        playerStats[ RPG_Agility ]   += 1;
        playerStats[ RPG_Accuracy ]  += 1;
        playerStats[ RPG_Strength ]  += 2;
        playerStats[ RPG_Defence ]   += 2;
        playerStats[ RPG_MaxHealth ] += 4;
        playerStats[ RPG_MaxArmor ]  += 4;
    }


    double GetScatterMultiplier( void ) {
        return DRRPUtil.Power( DRRPUtil.e * 0.3725, -GetFeature( RPG_Accuracy ) );
    }

    virtual int getRPGAttackDamage( int min, int max = 0 ) {
        if ( ( max == 0 ) || ( max < min ) )
            max = min;

        //int damageMultiplier = DRRPUtil.Power( GetFeature( RPG_Strength ), 0.6 ) * 0.33 + 0.67;
        int damageMultiplier = GetFeature( RPG_Strength ) * 0.33 + 0.67;

        return Random( min + damageMultiplier, max + damageMultiplier );
    }

    virtual int getRPGDefenceDamage( int damage, name mod ) {

        //CVar DebugCVar = CVar.GetCVar( "drrp_debug_mode", self.player );
        //if ( DebugCVar && DebugCVar.GetBool() )
        //    console.printf( GetClassName() .. "::getRPGDefenceDamage(). Incoming damage: " .. damage .. "; DamageType: " .. mod .. "." );

        damage *= DRRPUtil.Power( DRRPUtil.e * 0.378, -( 1 + playerStats[ RPG_Defence ] ) ) + 0.053;

        if ( self.player.ReadyWeapon ) {
            String ReadyWeapon = "";

            ReadyWeapon = self.player.ReadyWeapon.GetClassName();
            // Player may have not any weapons, for example, in 
            //the Sector 3, Nadira's hall.

            if ( ( ReadyWeapon ~== "DRRPAxe" ) && ( mod != 'DRRPFireDmg' ) ) {
                S_Sound( "weapon/axe/block", CHAN_AUTO, 0.67 );
                return damage / 2;
            }

            for ( int i = 0; i < DRRPPlayer.dogNames.Size(); i++ ) {
                if ( ReadyWeapon.Left( DRRPPlayer.dogNames[ i ].Length() ) == DRRPPlayer.dogNames[ i ] ) {
                    S_Sound( "monsters/hellhound/pain", CHAN_WEAPON, 0.5 );
                    TakeInventory( DRRPPlayer.dogNames[ i ] .. "Health", damage );

                    if ( FindInventory( DRRPPlayer.dogNames[ i ] .. "Health" ).Amount == 0 ) {
                        TakeInventory( ReadyWeapon, 1 );
                        S_Sound( "monsters/hellhound/death", CHAN_WEAPON, 0.5 );
                    }

                    return 0;
                }
            }
        }

        return damage;

    } // of play virtual int getRPGDefenceDamage( int damage, name mod ) {
}
