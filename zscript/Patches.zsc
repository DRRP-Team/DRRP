/**
 *Copyright (c) 2018-2019 DRRP-Team
 *
 *This software is released under the MIT License.
 *https://opensource.org/licenses/MIT
 */

class DRRPLava_ZSPatch: Actor {

    int fireActorDamageMin, fireActorDamageMax, fireActorDamageTicks;

    void damageNearestPlayers( void ) {
        for ( int i = 0; i < MAXPLAYERS; i++ ) {
            if ( !( level.maptime % fireActorDamageTicks ) && PlayerInGame[ i ] && Distance3D( players[ i ].mo ) < 32 )
                Players[ i ].mo.DamageMobj( self, self, random( fireActorDamageMin, fireActorDamageMax ), "DRRPFireDmg" );
        } // of for ( uint8 i = 0; i < MAXPLAYERS; i++ )
    } // of void damagePlayers( void )

    override void BeginPlay() {
        fireActorDamageMin = 3;
        fireActorDamageMax = 6;
        fireActorDamageTicks = 2;
    } // of override void BeginPlay()

    override void Tick() {
        damageNearestPlayers();
        Super.Tick();
    } // of override void Tick()

    override bool CanCollideWith( Actor other, bool passive ) {

        String cn = other.getClassName();
        if ( cn ~== "DoomRPGPlayer"
                || cn ~== "Phantom"
                || cn ~== "DRRPLostSoul"
                || cn ~== "Nightmare"

                || cn ~== "Beholder"
                || cn ~== "Rahovart"
                || cn ~== "DRRPPainElemental"

                || cn ~== "Infernis"
                || cn ~== "DRRPArchVile"
                || cn ~== "Apollyon"

                || cn ~== "BulletPuff"

                || ( ( other.bMISSILE == true ) && ( cn != "FireExtPuff") ) ) {
            return false;
        }

        return true;
    } // of override bool CanCollideWith( Actor other, bool passive )
}

class DRRPFire_ZSPatch: DRRPLava_ZSPatch {

    override void BeginPlay() {
        fireActorDamageMin = 1;
        fireActorDamageMax = 2;
        fireActorDamageTicks = 3;
    } // of override void BeginPlay()

    override void Tick() {
        damageNearestPlayers();

        //float ScaleTo = -0.5 * exp( 1 - ( float( health / SpawnHealth() ) ) ) + 1.5;
        //float ScaleTo = 1 / ( 0.66 + ( 1 - float( health ) / float( SpawnHealth() ) ) ) - 0.5;
        float ScaleTo = float( health ) / float( SpawnHealth() );
        float ScaleNow = ( ScaleTo < Scale.x )? Scale.x - ( ( Scale.x - ScaleTo ) / 15 ): ScaleTo;
        self.Scale = ( ScaleNow, ScaleNow );

        Super.Tick();
    } // of override void Tick()

}

class DRRPExplosion_ZSPatch: Actor {

    override void PostBeginPlay() {
        if ( pos.z <= ( FloorZ + self.height ) ) SetZ( FloorZ + ( self.height * 1.5 ) );
    }

}

class DRRPCharacter_ZSPatch: Actor {

    void A_DRRP_TransformationParticles( void ) {
        Actor TransfParticleActor = Spawn( "DRRPTransformationParticle", 
                                ( Random( 0, 20 ), Random( 0, 20 ), Random( 10, 40 ) ) );
        TransfParticleActor.master = self;
    } // of void A_DRRP_TransformationParticles( void )
}

class DRRPPlayer: DoomPlayer {

    int Experience, NextLevelXP, Level, Accuracy, Agility, Defense, Strength;

	override void BeginPlay() {
		Experience = Accuracy = Agility = Defense = Strength = 0;
		Level = 1;
		NextLevelXP = 18;
		Super.BeginPlay();
	}

    static int GetFeature( Actor activator, int type ) {
		if ( activator && activator.player && ( activator is "DRRPPlayer" ) ) {
			DRRPPlayer player = DRRPPlayer( activator );
	        switch ( type ) {
	            case RPG_MaxHealth:  return player.MaxHealth;
	            case RPG_Experience: return player.Experience;
	            case RPG_NextLevelXP:return player.NextLevelXP;
	            case RPG_Level:      return player.Level;
	            case RPG_MaxArmor:   break;//returns "200" //return self.FindInventory( "BasicArmor" ).MaxAmount;
	            case RPG_Accuracy:   return player.Accuracy;
	            case RPG_Agility:    return player.Agility;
	            case RPG_Defense:    return player.Defense;
	            case RPG_Strength:   return player.Strength;
	            default: break;
	        }
		} // of if ( activator && activator.player && ( activator is "DRRPPlayer" ) ) {
        return -1;
    }

    static void SetFeature( Actor activator, int type, int value ) {
        if ( ( value < 0 ) || !activator || !activator.player || !( activator is "DRRPPlayer" ) ) return;
		DRRPPlayer player = DRRPPlayer( activator );
        switch ( type ) {
            case RPG_MaxHealth:  player.MaxHealth = value; break;
            case RPG_Experience: player.Experience = value; break;
            case RPG_NextLevelXP:player.NextLevelXP = value; break;
            case RPG_Level:      player.Level = value; break;
            case RPG_MaxArmor:   break;//self.FindInventory( "BasicArmor" ).MaxAmount = value;
            case RPG_Accuracy:   player.Accuracy = value; break;
            case RPG_Agility:  { player.Agility = value; RPGSystemHandler.setAllFeatures( player ); break; }
            case RPG_Defense:    player.Defense = value; break;
            case RPG_Strength:   player.Strength = value; break;
            default: break;
        }
    }

}