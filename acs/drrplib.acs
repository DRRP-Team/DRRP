#library "drrplib"
#include "zcommon.acs"

const int SECONDS = 35; /* Ticks per second */

/* HUD Alignment Anchor */
const fixed HUD_CENTER = 0.0;
const fixed HUD_TOP = 0.1;
const fixed HUD_BOTTOM = 0.2;
const fixed HUD_LEFT = 0.1;
const fixed HUD_RIGHT = 0.2;

/* Useful functions */

function void throw(str error) {
    Print(s:"[ERROR] ", s:error);
    Log(s:"[ERROR] ", s:error);
    int a[3] = {1, 2, 3};
    print(i:a[999]);
}

function fixed toFixed(int value) {
    return value << 16;
}

function int toInt(fixed value) {
    return value >> 16;
}

function int toFloor(fixed value) {
    if (value < 10000) {
        return value;
    }

    return toInt(value);
}

/* Can be used if you don't have enough script parameters */
function int encodeXY(int x, int y) {
    return (x << 16) | y;
}

function int decodeX(int encoded) {
    return encoded >> 16;
}

function int decodeY(int encoded) {
    return encoded & 0xFFFF;
}

function bool isLocalized(str string) {
    return !!strcmp(StrParam(l:string), string);
}


function bool isUnicodeSymbol(int symbol) {
    return symbol < 0;
}

function int unilen(str text) {
    int len = 0;
    int unicodeChars = 0;

    while (text[len] != 0) {
        if (text[len] < 0) unicodeChars++;
        len++;
    }

    return len - (unicodeChars / 2);
}

function str at(str text, int position) {
    int pos = 0;
    while(true) {
        int sym = text[pos];

        if (pos == position * 2) {
            return isUnicodeSymbol(sym)
                ? StrParam(c:sym, c:text[pos + 1])
                : StrParam(c:sym);
        }

        if (sym > 0) pos += 2;
        else if (sym == 0) return "";
        else pos += 1;
    }
}

function int getStringWidth(str String) {
    return UniLen(String);
}

function int getStringHeight(str String) {
    int i      = 0;
    int height = 0;

    while(String[i] != '\0') {
        if(String[i++] == '\n') height++;
    }
    return height;
}

function global str getThingName(int id, int state) {
    Print(s:"getThingName(", i:id, s:", ", i:state, s:")");
    return "DRRPTODO";
}

function int getAimedActorTid(void) {
    return PickActor(0, GetActorAngle(0), GetActorPitch(0), 100.0, 5005,
        MF_NOBLOOD, 0, PICKAF_RETURNTID);
}

function str getAimedActor(void) {
    int tid = getAimedActorTid();
    return GetActorClass(tid);
}

function str getAimedActorDialogueType(void) {

    str class = getAimedActor();
    if(GetCVar("drrp_debug_mode")) print(s:class);

    /* if (!StriCmp(class, "Civilian")) return 2; */
    if (!StriCmp(class, "DRRPComputer")) return 1;
    /* if (!StriCmp(class, "DRRPPlayer")) return -1; */

    return 0;
}

function int getThingSpecialArg(int tid, int spec, int arg) {
    return ScriptCall("ConversationController", "GetActorArgument", tid, spec, arg);
}

Script "TestDialogueType" (void) {
    print(i:getAimedActorDialogueType());
}

function str localizeSound(str sound) {
    if(GetCVar("drrp_debug_mode")) Print(s:"localizeSound(", s:sound, s:") [", l:"DRRP_D_SOUND_SUFFIX", s:"]");
    return StrParam(s:sound, l:"DRRP_D_SOUND_SUFFIX");;
}

function int imax(int val1, int val2) {
    return val1 > val2 ? val1 : val2;
}

function int imin(int val1, int val2) {
    return val1 < val2 ? val1 : val2;
}

function fixed fmax(fixed val1, fixed val2) {
    return val1 > val2 ? val1 : val2;
}

function fixed fmin(fixed val1, fixed val2) {
    return val1 < val2 ? val1 : val2;
}

function fixed fclamp(fixed value, fixed min, fixed max) {
    return fmax(min, fmin(max, value));
}

function int idivF(int a, int b) {
    return toFixed(a) / toFixed(b);
}

function int idivI(int a, int b) {
    return toFloor(idivF(a, b));
}

function str StrAdd(str a, str b) {
    return StrParam(s:a, s:b);
}


function str removeChar(str string, int charToRemove) {
    str output = "";

    int len = StrLen(string);

    for (int i = 0; i < len; i++) {
        if (string[i] != charToRemove)
            output = StrParam(s:output, c:string[i]);
    }

    return output;
}

function str replaceChar(str string, int char, int charToReplace) {
    str output = "";

    int len = StrLen(string);

    for (int i = 0; i < len; i++) {
        if (string[i] == char)
            output = StrParam(s:output, c:charToReplace);
        else
            output = StrParam(s:output, c:string[i]);
    }

    return output;
}

function str removeNewLines(str string) {
    str output = "";

    int len = StrLen(string);

    for (int i = 0; i < len; i++) {
        if (string[i] == '\n') {
            if (i + 1 < len && string[i + 1] != ' ')
                output = StrParam(s:output, c:' ');
        } else {
            output = StrParam(s:output, c:string[i]);
        }
    }

    return output;
}

function str StrLTrim(str string) {
    int len = StrLen(string);
    int spaces = 0;
    for (; string[spaces] == ' '; spaces++) {}

    return StrRight(string, len - spaces);
}

function str StrRTrim(str string) {
    int len = StrLen(string);
    int wordLen = len - 1;
    for (; string[wordLen] == ' '; wordLen--) {}

    return StrLeft(string, wordLen + 1);
}

function str StrTrim(str string) {
    str trim = StrLTrim(StrRTrim(string));
    /* print(s:"StrTrim(", s:string, s:") = ", s:trim, c:'|', i:StrLen(trim)); */
    return trim;
}

function str StrPadRight(str original, int length, int symbol) {
    int len = StrLen(original);
    if (len >= length) return original;

    for (int i = 0; i < length - len; i++) {
        original = StrParam(s:original, c:symbol);
    }

    return original;
}


int lastInput = -1;
int lastInputIdx = 0;
int lastInputReadIdx = -1;

const int INPUT_ESC = 8;

function int onInput(void) {
    if (lastInputIdx == lastInputReadIdx) return 0;

    lastInputReadIdx = lastInputIdx;

    return lastInput;
}

// #define DEBUG_INPUT

Script "onInput" (int sym) {
#ifdef DEBUG_INPUT
    Print(s:"On input ", i:sym, s:" ", c:sym);
#endif
    lastInput = sym;
    lastInputIdx++;
}


function str drrpFont(void) {
    int font = GetCVar("drrp_font");

    switch (font) {
        case 1: return "defsmallfont2"; /* DRPG */
        case 2: return "defsmallfont1"; /* GZDOOM */
        default: throw("INVALID FONT");
    }
}

function int drrpFontWidth(void) {
    return 9;

    int font = GetCVar("drrp_font");

    switch (font) {
        case 1: return 9; /* DRPG */
        case 2: return 9; /* GZDOOM */
        default: throw("INVALID FONT");
    }
}

function int drrpFontHeight(void) {
    int font = GetCVar("drrp_font");

    switch (font) {
        case 1: return 12; /* DRPG */
        case 2: return 9; /* GZDOOM */
        default: throw("INVALID FONT");
    }
}

#define BUTTONS_STATES_LEN 13

/*
 * 0 - Not pressed
 * 1 - Pressed
*/

int _buttonStates[BUTTONS_STATES_LEN][2] = {
    { BT_ATTACK, 0 },
    { BT_USE, 0 },
    { BT_JUMP, 0 },
    { BT_CROUCH, 0 },
    { BT_ALTATTACK, 0 },
    { BT_SPEED, 0 },
    { BT_MOVERIGHT, 0 },
    { BT_MOVELEFT, 0 },
    { BT_BACK, 0 },
    { BT_FORWARD, 0 },
    { BT_RIGHT, 0 },
    { BT_LEFT, 0 },
    { 33554432, 0 }, /* BT_RUN */
};

function int _getBtnStateIndex(int button) {
    for (int i = 0; i < BUTTONS_STATES_LEN; i++) {
        if (_buttonStates[i][0] == button) return i;
    }

    return -1;
}

function void onBtnReset(void) {
    for (int i = 0; i < BUTTONS_STATES_LEN; i++) {
        _buttonStates[i][1] = 1;
    }
}

function bool onBtnClick(int button) {
    int input = GetPlayerInput(-1, INPUT_BUTTONS);

    int idx = _getBtnStateIndex(button);

    if (idx == -1) throw("INVALID BUTTON");

    /* print(s:"onBtnPress Btn: ", i:button, s:" State: ", b:_buttonStates[idx][1]); */

    if (!(input & button)) {
        _buttonStates[idx][1] = 0;
        return false;
    }

    if (_buttonStates[idx][1] == 0) {
        _buttonStates[idx][1] = 1;
        return true;
    }

    return false;
}

function bool onBtnPress(int button) {
    int input = GetPlayerInput(-1, INPUT_BUTTONS);

    return input & button;
}

const str INTERNAL_META_STRING_KEY = "drrp_internal_metastring";

function str GetInternalMetaString(void) {
    return GetUserCVarString(0, INTERNAL_META_STRING_KEY);
}

function void SetInternalMetaString(str data) {
    SetUserCVarString(0, INTERNAL_META_STRING_KEY, data);
}

function void pauseGame(void) {
    ScriptCall("ConversationController", "SetGlobalFreeze", true);
    /* Prevent mouse move glitches */
    SetPlayerProperty(0, true, PROP_TOTALLYFROZEN);
}

function void resumeGame(void) {
    SetPlayerProperty(0, false, PROP_TOTALLYFROZEN);
    ScriptCall("ConversationController", "SetGlobalFreeze", false);
}

function void SpawnWithFog(str classname, float x, float y, float z, int assignTid) {
    SpawnForced("TeleportFog", x, y, z);
    SpawnForced(classname, x, y, z, assignTid);
}
