/**
 * Copyright (c) 2017-2022 DRRP-Team
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

#import "drrplib.acs"
#include "zcommon.acs"

/* DEPRECATED */
Script "fireextfade" (int mode) {
    // TODO: Use additive point light
    if(mode) {
        // Sector_SetFade(0, 255, 255, 255);
    } else {
        // Sector_SetFade(0, 0, 0, 0);
    }
}

/* ACS based DRPG Window */

/*
 This crutch fixes the GZDoom Encoding bug in russian translation
 https://trello.com/c/Yjn7YM8b
*/
function str fixEncodingBug(str text) {
    str output;
    int TextLen = strlen(text);
    for (int i = 0; i < TextLen; i++) {
        if (text[i] == 0x20) /* space */
            output = StrParam(s:output, s:" ");
        else
            output = StrParam(s:output, c:text[i]);
    }

    return output;
}

function float fapplyScaleF(float value) {
    float SCALE = GetCVar("drrp_window_scale");

    return value / SCALE;
}

function float iapplyScaleF(int value) {
    float val = toFixed(value);

    return fapplyScaleF(val);
}

function int fapplyScaleI(float value) {
    return toFloor(fapplyScaleF(value));
}

function int iapplyScaleI(int value) {
    return toFloor(iapplyScaleF(value));
}

/* // String wrap processor \\ */

const bool DEBUG_STRINGWRAP = false;

function str copyString(str text) {
    return StrLeft(text, StrLen(text));
}

function int readWordLength(str text) {
    /* if (DEBUG_STRINGWRAP) print(s:"readWordLength ", s:text); */
    int i = 0;

    while (true) {
        int sym = text[i];

        /* print(s:"Sym ", c:sym); */

        if (sym == ' ' || sym == 0x0) return ++i;

        i++;
    }

    return i;
}

function str wrapWord(str word, int maxLength) {
    /* if (DEBUG_STRINGWRAP) print(s:"wrapWord ", s:word, c:' ', i:maxLength); */

    if (maxLength == 0) return StrParam(c:'\n', s:word);

    int len = StrLen(word);
    str output = StrLeft(word, maxLength);
    str remaining = StrRight(word, len - maxLength);

    int curChar = output[maxLength - 1];

    /* Add hyphen */
    if (curChar >= 'A') output = StrParam(s:output, c:'-');

    output = StrParam(s:output, c:'\n', s:remaining);

    if (DEBUG_STRINGWRAP) print(s:"wrapWord()-output ", s:output, c:'|');

    return output;
}


function str wrapText(str text, int maxLength) {
    text = StrTrim(removeNewLines(text));
    if (DEBUG_STRINGWRAP) print(s:"wrapText ", s:text, c:' ', i:maxLength);
    int len = strlen(text);
    int wordLen = 0;

    str remaining = copyString(text);
    str output;
    int currentLineLength = 0;

    while (wordLen <= len) {
        wordLen = readWordLength(remaining);

        str word = StrTrim(StrLeft(remaining, wordLen));
        len -= wordLen;
        remaining = StrTrim(StrRight(remaining, len));

        int lineFullLength = currentLineLength + wordLen;

        if (lineFullLength < maxLength) {
            output = StrParam(s:output, c: ' ', s:word);
            currentLineLength += wordLen;
            continue;
        }

        int extraChars = lineFullLength - maxLength;
        int charsToBeWrappedAfter = wordLen - extraChars;

        /* Do not wrap single character */
        if (extraChars <= 2) charsToBeWrappedAfter -= 1;

        /* Do not wrap symbol */
        if (word[charsToBeWrappedAfter + 1] < 'A') charsToBeWrappedAfter--;;

        /* Write whole word on next line if needed */
        if (charsToBeWrappedAfter < 4) charsToBeWrappedAfter = 0;

        if (DEBUG_STRINGWRAP) print(s:"Wrap word: '", s:word, s:"' extraChars ", i:extraChars, s:" after ", i:charsToBeWrappedAfter, s:" line length: ", i:lineFullLength);

        str wrappedWord = wrapWord(word, charsToBeWrappedAfter);

        if (DEBUG_STRINGWRAP) print(s:"WrappedWord = ", s:wrappedWord, c:'|');

        currentLineLength = extraChars;
        output = StrParam(s:output, c: ' ', s:wrappedWord);
        if (DEBUG_STRINGWRAP) print(s:"line wrapped ", s:output, s:" length ", i:currentLineLength);
    }

    return StrTrim(output);
}

Script "testwrapper" (str text, int maxLength) {
    print(s:wrapText("Hello world! THis is a very long text and must to be wrapped!!!", maxLength));
}

/* \\ String wrap processor // */

const int WINDOW_LEN = 20; /* Chars in one line */

function int getClipHeight(void) {
    int font = GetCVar("drrp_font");

    switch (font) {
        case 1: return 60; /* DRPG */
        case 2: return 64; /* GZDOOM */
        default: throw("INVALID FONT");
    }
}

function int getLinesOnScreen(void) {
    int font = GetCVar("drrp_font");

    switch (font) {
        case 1: return 5; /* DRPG */
        case 2: return 7; /* GZDOOM */
        default: throw("INVALID FONT");
    }
}

function int getColorByType(int type) {
    switch (type) {
        case 1: return CR_GREEN; /* Terminal */
        case 2: return CR_RED; /* Evil */
        case 3: return CR_YELLOW; /* Hint */
        case 4: return CR_ORANGE; /* Martians */
        case 5: return CR_YELLOW; /* Level Up */
        case 0: /* Dialogue */
        default:
            return CR_WHITE;
    }
}

function int getBgColorByType(int type) {
    switch (type) {
        case 1: return CR_DARKGREEN; /* Terminal */
        case 2: return CR_DARKRED; /* Evil */
        case 3: return CR_BLACK; /* Hint */
        case 4: return CR_ORANGE; /* Martians */
        case 5: return CR_BLACK; /* Level Up */
        case 0: /* Dialogue */
        default:
            return CR_WHITE;
    }
}

function void drawDialogFrame(int posX, int posY, bool scrollable, int type) {
    SetHudSize(iapplyScaleI(640), iapplyScaleI(480), true);
    SetFont("M_DIALOG");
    HudMessage(i: scrollable; HUDMSG_PLAIN, -10000000, getBgColorByType(type),
        toFixed(posX) + HUD_LEFT,
        toFixed(posY - 5) + HUD_TOP,
        1);
}

function void drawDialogWindow(str Text, int posX, int posY, int ScrollY, int type) {
    SetHudSize(iapplyScaleI(640), iapplyScaleI(480), true);
    SetHUDClipRect(0, 0, 0, 0, 0);

    drawDialogFrame(posX, posY, ScrollY >= 0, type);

    if (ScrollY < 0) ScrollY = 0;

    SetFont(drrpFont());
    SetHudClipRect(
        posX,
        posY,
        160 - 2,
        getClipHeight(),
        0, true);
    HudMessage(s: Text;
        HUDMSG_PLAIN,
        -10000001, /* id */
        getColorByType(type),
        toFixed(posX + 4) + HUD_LEFT,
        toFixed(posY - (ScrollY * drrpFontHeight())) + HUD_TOP,
        1); /* hold */

    SetHudSize(0, 0, false);
}

function void drawDialogTypingWindow(str Text, int posX, int posY, bool scrollable, int type) {
    SetHudSize(iapplyScaleI(640), iapplyScaleI(480), true);
    SetHUDClipRect(0, 0, 0, 0, 0);

    drawDialogFrame(posX, posY, scrollable, type);

    SetFont(drrpFont());
    SetHudClipRect(
        posX,
        posY,
        160 - 2,
        getClipHeight(),
        0, true);
    HudMessage(s: Text;
        HUDMSG_TYPEON,
        -10000001, /* id */
        getColorByType(type),
        toFixed(posX + 4) + HUD_LEFT,
        toFixed(posY) + HUD_TOP,
        10.0, /* hold */
        0.01,
        1); /* fadeout */

    SetHudSize(0, 0, false);
}

function void clearDialogWindow(void) {
    HudMessage(s: ""; HUDMSG_PLAIN, -10000000, 0, 0.5, 0.8, 1);
    HudMessage(s: ""; HUDMSG_PLAIN, -10000001, 0, 0.5, 0.8, 1);
}

function void exitDialogWithoutSave(void) {
    int tid = getAimedActorTid();

    int scriptNo = GetThingSpecialArg(tid, ACS_Execute, 0);

    ACS_Terminate(scriptNo, 0);
}

const int BEEP_SPEED_DIV = 2;

Script "beeping" (int len, int type) {
    if (!GetCVar("drrp_enable_beep")) Terminate;

    for (int i = 0; i < len / BEEP_SPEED_DIV; i++) {
        AmbientSound("misc/chat2", GetCVar("drrp_beep_volume"));
        Delay(BEEP_SPEED_DIV);
    }
}

Script "window" (str _Text, int type) {
    const int posX = iapplyScaleI(320) - 80;
    const int posY = iapplyScaleI(322);

    if (!type) {
        type = getAimedActorDialogueType();
    }

    str Text = fixEncodingBug(_Text);

    ScriptCall("ConversationController", "SetGlobalFreeze", true);
    /* Prevent mouse move glitches */
    SetPlayerProperty(0, true, PROP_TOTALLYFROZEN);

    Delay(2);

    int ReadedKey;
    int FirstRun = 1;
    int ScrollY  = 0;
    int height   = getStringHeight(Text);

    bool enableScroll = height >= getLinesOnScreen();

    if (!enableScroll) ScrollY = -1;

    ACS_NamedExecute("beeping", 0, UniLen(Text), type);

    drawDialogTypingWindow(Text,
        posX,
        posY,
        enableScroll,
        type
    );

    int typingDelayTimer = 0;

    While(TRUE) {
        typingDelayTimer++;

        if (typingDelayTimer > 32) {
            if(enableScroll && ReadedKey & BT_FORWARD && ScrollY > 0) {
                ScrollY--;
                Delay(4);
            }
            if(enableScroll && ReadedKey & BT_BACK && ScrollY + getLinesOnScreen() <= height) {
                ScrollY++;
                Delay(4);
            }

            ACS_NamedTerminate("beeping", 0);
            drawDialogWindow(Text, posX, posY, ScrollY, type);
        }

        Delay(1);

        ReadedKey = GetPlayerInput(-1, INPUT_BUTTONS);

        if((FirstRun == 0) && (ReadedKey & BT_USE)) {
            break;
        }
        if((FirstRun == 1) && !(ReadedKey & BT_USE))
            FirstRun = 0;

        if (   (ReadedKey & BT_MOVELEFT)
            || (ReadedKey & BT_MOVERIGHT)
            || (ReadedKey & BT_JUMP)
            || (ReadedKey & BT_CROUCH)
            ) {
            exitDialogWithoutSave();
            break;
        }
    }

    clearDialogWindow();
    ACS_NamedTerminate("beeping", 0);

    SetPlayerProperty(0, false, PROP_TOTALLYFROZEN);
    ScriptCall("ConversationController", "SetGlobalFreeze", false);
}

Script "hintwindow" (str _Text, int holdTicks) {
    str Text = wrapText(fixEncodingBug(_Text), WINDOW_LEN);
    Log(s:Text);

    Delay(2);

    const int FINAL_POS_X = 410;
    const int FINAL_POS_Y = 10;

    const int ANIMATION_OFFSET = 200;
    const int ANIMATION_SPEED = 20;

    /* In animation */

    for (int i = ANIMATION_OFFSET; i >= 0; i-=ANIMATION_SPEED) {
        drawDialogWindow(Text,
            iapplyScaleI(FINAL_POS_X + i),
            iapplyScaleI(FINAL_POS_Y),
            -1,
            3
        );
        Delay(1);
    }

    Delay(holdTicks);

    for (int i = 0; i < ANIMATION_OFFSET; i+=ANIMATION_SPEED) {
        drawDialogWindow(Text,
            iapplyScaleI(FINAL_POS_X + i),
            iapplyScaleI(FINAL_POS_Y),
            -1,
            3
        );
        Delay(1);
    }

    clearDialogWindow();
}

Script "lockwindow"(str Text, str Password, int ScriptNumber) {
    ScriptCall("DoorCodeInputActor", "DoorCode", Text, Password, ScriptNumber);
    Delay(2);
}

Script "drawwindow" (str _Text, bool typing, int type) {
    const int posX = iapplyScaleI(320) - 80;
    const int posY = iapplyScaleI(322);
    const int TYPING_DELAY = 32;

    if (!type) {
        type = getAimedActorDialogueType();
    }

    str Text = fixEncodingBug(_Text);

    Delay(2);

    if (typing) {
        ACS_NamedExecute("beeping", 0, UniLen(Text), type);

        drawDialogTypingWindow(Text,
            posX,
            posY,
            false,
            type
        );
    }

    int typingDelayTimer = typing ? 0 : TYPING_DELAY;

    While(TRUE) {
        typingDelayTimer++;

        if (typingDelayTimer > TYPING_DELAY) {
            ACS_NamedTerminate("beeping", 0);
            drawDialogWindow(Text, posX, posY, -1, type);
            break;
        }

        Delay(1);
    }
}

Script "clearwindow" (void) {
    clearDialogWindow();
    ACS_NamedTerminate("beeping", 0);
}

const int BLOOD_FLASH_ID = 30;
const int BLOOD_FLASH_LAYERS = 2;

// Player's bloody damage flash visual effect.
int flashMessageID = BLOOD_FLASH_ID;
Script "BloodFlashVisual" ( int flashType, int receivedDamage ) {
	if (!GetCVar("drrp_enable_blood_flashes")) Terminate;

	if ( flashType == 0 ) flashType = Random(1, 4);

    if ( flashType > 0 && flashType < 4 ) {
        // Cyclic HudMessage id:
		flashMessageID = ((flashMessageID + 1) % BLOOD_FLASH_LAYERS) + BLOOD_FLASH_ID;

        SetHudSize( 64, 64, false );
        SetFont( StrParam( s:"SPLASH_", i:flashType ) );
        HudMessage( s: "a"; HUDMSG_FADEOUT | HUDMSG_ALPHA, flashMessageID, CR_GRAY, 32.0, 32.0, 0.33, 0.5, 0.3);
    }
}

Script "drpgquake"(int time, int intensivity) {
    ACS_Execute(3008, 0, time, intensivity);
    if(GetCVar("drrp_debug_mode")) Print(s:"[DEBUG]: Using DEPRECATED Script drpgquake");
}

Script "transformation"(int tid, int timedelay) {
    if(GetCVar("drrp_debug_mode")) Print(s:"[DEBUG]: Using correct Script transformation");
    if(tid < 0) tid *= -1;

    SetActorState(tid, "Turn");
    Delay(timedelay || 2);
}

/**
 * RPG System
 */

// For "/ZScript/RPGSystem.zsc":
enum RPGGetFeatureStaticTypes {
    RPG_Level,
    RPG_Experience,
    RPG_NextLevelXP,

    RPG_MaxHealth,
    RPG_MaxArmor,

    RPG_Accuracy,
    RPG_Agility,
    RPG_Defense,
    RPG_Strength
};

bool hasKillsAchievement = false;
bool hasSecretsAchievement = false;


Script "LevelDoneNotifierVisual" ( void ) {
    int monsterstotal  = GetLevelInfo( LEVELINFO_TOTAL_MONSTERS );
    int monsterskilled = GetLevelInfo( LEVELINFO_KILLED_MONSTERS);

    int secretstotal   = GetLevelInfo( LEVELINFO_TOTAL_SECRETS  );
    int secretsfound   = GetLevelInfo( LEVELINFO_FOUND_SECRETS  );

    SetFont( "BIGFONT" );

    if ( monsterstotal && monsterskilled == monsterstotal && !hasKillsAchievement ) {
        HudMessage( l:"DRRP_D_ACH_MONSTERS"; HUDMSG_TYPEON | HUDMSG_LOG, 18, CR_GRAY, 1.5, 0.82, 3.0, 0.005, 1.0 );
        LocalAmbientSound( "COMPLETE", 115 );
        hasKillsAchievement = true;
    }

    if ( secretstotal && secretsfound == secretstotal && !hasSecretsAchievement ) {
        HudMessage( l:"DRRP_D_ACH_SECRETS"; HUDMSG_TYPEON | HUDMSG_LOG, 18, CR_GRAY, 1.5, 0.82, 3.0, 0.005, 1.0 );
        LocalAmbientSound( "SECRETS", 115 );
        hasSecretsAchievement = true;
    }
}

Script "levelUp" (bool windowOnly) {
    int pLevel = ScriptCall("DRRPPlayer", "GetFeatureStatic", RPG_Level);

    if (!windowOnly) {
        pLevel++;
        ScriptCall("DRRPPlayer", "SetFeatureStatic", RPG_Level, pLevel);
    }

    ActivatorSound("player/levelup", 127);
    ACS_NamedExecuteWait("window", 0, StrParam(
        s:"- ", l:"DRRP_B_ID78", s:" -\n",  // Level up!
        l:"DRRP_B_ID76", i:pLevel, s:"\n",  // Level:
        l:"DRRP_B_ID74", i:4, s:"\n",       // Max Health:
        l:"DRRP_B_ID72", i:4, s:"\n",       // Max Armor:
        l:"DRRP_B_ID73", i:2, s:"\n",       // Defense:
        l:"DRRP_B_ID75", i:2, s:"\n",       // Strength:
        l:"DRRP_B_ID71", i:1, s:"\n",       // Accuracy:
        l:"DRRP_B_ID70", i:1, s:"\n\n",     // Agility:
        l:"DRRP_B_ID77"), 5);                  // Health restored.
}


#include "inc_flashlight.acs"
#include "inc_mapapis.acs"
#include "inc_shaders.acs"